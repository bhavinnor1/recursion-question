# -*- coding: utf-8 -*-
'''
A world-renowned pixel artist Fred Zuppa has recently produced several
masterpieces in the form of square raster images encoded on grayscale
pixels. The images he has drawn can take values from 0 to 255
inclusive. Unfortunately the famous works have been lost because his
hard disk (alas!) stopped working and obviously Fred is desperate.
Programs to recover them from the filesystem don't work unfortunately
and so Fred relies on his trusted computer scientist, who tells him:

  "Bro, in truth I say to you, if you remember the
   size of the images and the values of the pixels along with the
   particular properties of your images, then we can try to write a
   recursive generator that will produce all of them based on your
   your inputs, that way we can try to retrieve them!"

The next morning Fred is able to give the necessary information in the
form of:
   1. `D` integer parameter describing the size of the square image.
   2. `colors` a list of integers describing the colors of Fred's
      images.  Fred's colors are between 0, 255.  colors can therefore
      be [128, 0, 255] while it cannot be [-100, 999]
   3. A text `img_properties` describing the properties of his images.
      The text can describe no properties (empty string) or can describe
      a property related to the pattern to be found in the images.

      For example:

      If `img_properties` is empty then the images do not need to satisfy 
      any property. On the contrary, if `img_properties` is equal to
      'pattern_{type}_' then the images have to contain the pattern
       specified in the string.

      The type of patterns are the following four:
       a) 'pattern_diff_': it indicates that by taking
       arbitrarily a subimage of size equal to 2x2, the subimage
       must have all pixels of different colors.

                 valid        not valid
            |  96 | 255 |   |   0 | 255 |
            | 128 |   0 |   | 255 |  96 |
              

        b) 'pattern_cross_': it indicates that by taking
       arbitrarily a subimage of equal to 2x2 in Fred's images,
       this subimage must have pixels on the diagonal all equal
       and the pixels on the anti-diagonal all equal
       but the two diagonals must be different in colors.

               valid          not valid     not valid
            |  96 | 255 |   |  0 | 255 |   | 61 | 61 |
            | 255 |  96 |   | 96 |   0 |   | 61 | 61 |

       c) 'pattern_hrect_': If present, this indicates that by taking
       arbitrarily a subimage of dimension equal to 2x2 in Fred's
       images, this subimage must have the pixels on the rows all
       equal but adjacent rows of different colors.

                 valid       not valid        not valid
            |   0 |   0 |   | 255 | 255 |    | 43 | 43 |
            | 128 | 128 |   | 0   | 255 |    | 43 | 43 |

       d) 'pattern_vrect_': If present, this indicates that by taking
       arbitrarily a subimage of dimension equal to 2x2 in Fred's
       images, this subimage must have the pixels on the columns all
       equal but adjacent columns with different colors.

                valid         not  valid    not valid
             | 0 | 255 |     | 0  | 0  |    | 22 | 22 |
             | 0 | 255 |     | 0  | 255|    | 22 | 22 |


Implement the recursive function or one that uses recursive methods:

      images = ex(colors, D, img_properties)

which takes as input the list of colors `colors`, the dimension of the
images `D` and a string `img_properties` which describes their
properties and recursively generates all images following the above
properties.  The function must return the enumeration of all valid
images as a list of images. Each image is a tuple of tuples where each
gray intensity is an integer. The order in which the images are
generated does not matter.

     Example: 2x2 image of zeros (all black) is:
         img = ( (0, 0), (0, 0), )

The timeout for each test is 1 second.

***
It is strongly advised to model the problem as a game tree, making
an effort to propagate only the necessary "moves" in the recursion and
thus construct an efficient solution. Alternatively, you can try to
"prune" the tree as soon as possible when building your solution.
***


You can view all images to be generated by invoking

     python test_01.py data/images_data_15.json

this saves all the expected images for test 15 images to disk and
creates an HTML file named `images_data_15.html` in the root directory
of the HW. You can view the images by opening the html file with a web
browser.
'''


def empty(mylist, r):
	if r==0:
		return [[]]
	L=[]
	for i in range (0,len(mylist)):
		first=mylist [i]
		rem=mylist
		comblist=empty(rem,r-1)
		for x in comblist:
			L.append((first,)+tuple(x))
	return L

def diff(mylist, r):
	if r==0:
		return [[]]
	L=[]
	for i in range(0,len(mylist)):
		first=mylist [i]
		rem=[]
		for j in mylist:
			if j!=mylist [i]:
				rem.append(j)
		comblist=diff(rem,r-1)
		for x in comblist:
			L.append([first]+x)
	return L

#def cross (mylist):
#	main=[]
#	c=[]
#	for i in range(len(mylist)):
#		c=[]
#		length=len(mylist [i])
#		for j in range (length-1, -1,-1):
#			c.append(mylist [i][j])
#		main.append(mylist [i]+c)
#	return main

def divider(mylist, d):
	a=len(mylist[0])
	l=[]
	for j in mylist:
		lst=[]
		for i in range(0, a, d):
			lst.append(tuple(j[i:i+d]))
		l.append(tuple(lst))
	return l

def vrect (mylist,d):
	main=[]
	for i in range(len(mylist)):
		c=[]
		for i in range(d):
			c+=mylist [i]
		main.append(c)
	return main

def hrect(rem,d):
	wrong=False
	iminus1=256
	c=[]
	for j in range (len(rem)):
		iminus1=256
		for i in range(len(rem[j])):
			if rem[j][i]==iminus1:
				wrong=True
				break
			iminus1=rem[j][i]
		if wrong==False:
			c.append(rem[j])
		else:
			wrong=False
	final=[]
	r=[]
	for i in range (len(c)):
		r=[]
		for j in range (len(c[i])):
			pixel=[]
			for k in range (d):
				pixel.append(c[i][j])
			r.append(tuple(pixel))
		final.append(tuple (r))
	return final

def vrect(rem,d):
	wrong=False
	iminus1=256
	c=[]
	for j in range (len(rem)):
		iminus1=256
		for i in range(len(rem[j])):
			if rem[j][i]==iminus1:
				wrong=True
				break
			iminus1=rem[j][i]
		if wrong==False:
			c.append(rem[j])
		else:
			wrong=False
	final=[]
	r=[]
	for i in range (len(c)):
		r=[]
		for j in range (d):
			r.append(tuple (c[i]))
		
		final.append(tuple (r))
	return final

def cross (rem2, d):
	final=[]
	for i in range (len(rem2)):
			r=[]
			n=0
			for j in range (d):
				r.append(rem2[i][n])
				if n==0:
					n=1
				else:
					n=0
			final.append(tuple (r))
	final2=[]
	for i in range (len(rem2)):
			r=[]
			n=1
			for j in range (d):
				r.append(rem2[i][n])
				if n==1:
					n=0
				else:
					n=1
			final2.append(tuple (r))
	
	final3=[]
	for i in range(len(final)):
		r=[]
		n=0
		for j in range (d):
			if n==0:
				r.append(tuple (final[i]))
				n=1
			else:
				r.append(tuple (final2[i]))
				n=0
		final3.append(tuple (r))
	return final3

def remove (mylist):
	rem2=[]
	w=False
	for i in mylist:
		i1=256
		for j in i:
			if j==i1:
				w=True
			i1=j
		if w==False:
			rem2.append(i)
		else:
			w=False
	return rem2

def diff_b(rem,d):
	rem2=[]
	w=False
	for i in rem:
		i1=256
		for j in i:
			if j==i1:
				w=True
				break
			i1=j
		if w==False:
			rem2.append(i)
		else:
			w=False
	#print (rem2)
	#print (len(rem2))
	final=[]
	finals=[]
	w=False
	for i in rem2:
		r=[]
		for j in rem2:
			if i==j:
				continue
			for k in range (d-1):
				lis=i[k:k+2]+j[k:k+2]
				#print ("lis = ",lis)
				if(len(set(lis)) == 4):
					continue
				else:
					w=True
					break
			r2=[]
			if w==False:
				r.append(j)
				r2.append(i)
				r2.append(j)
				finals.append(r2)
			else:
				w=False
		final.append(tuple (r))
	#print (final)
	#print (len(rem2))
	#print (len(final))
	final3=[]
	for i in finals:
		n=0
		r=[]
		for j in range (d):
			if n==0:
				r.append(i[n])
				n=1
			else:
				r.append(i[n])
				n=0
		final3.append(tuple (r))
	for i in range (len(final)):
		if len(final[i])!=d-1:
			continue
		else:
			three=[]
			l=list(final[i])
			for m in range (len(l)):
				if m%2!=0 and m!=0:
					three.append(rem2[i])
				three.append(l[m])
			#print (three)
			final3.append(tuple(three))
			threefour=[]
			for m in range (len(l)-1,-1,-1):
				if m%2==0:
					threefour.append(rem2[i])
				threefour.append(l[m])
			#print ("threefour",threefour)
			final3.append(tuple(threefour))
	
	#print (final3)
	#print (len(final3))
	return final3


def ex(colors, D, img_properties):
    print (img_properties)
    if img_properties=="":
    	mylist=empty(colors, D**2)
    	return divider(mylist, D)
    elif img_properties=="pattern_diff_":
     	if D==2:
     		mylist=diff(colors, D*D)
     		return divider(mylist, D)
     	else:
     		mylist=empty(colors, D)
     		return diff_b(mylist,D)
    elif img_properties=="pattern_cross_":
    	mylist=empty(colors, 2)
    	rem2=remove (mylist)
    	return cross(rem2,D)
    elif img_properties=="pattern_hrect_":
    	mylist=empty(colors, D)
    	return hrect(mylist,D)
    elif img_properties=="pattern_vrect_":
    	mylist=empty(colors, D)
    	return vrect(mylist,D)

if __name__ == '__main__':
    print (ex([0,96,128,255], 6, "pattern_diff_"))
